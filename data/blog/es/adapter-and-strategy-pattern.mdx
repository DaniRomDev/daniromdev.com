---
title: 'Patrones de diseño que puedes usar en tu dia a dia: Adapter & Strategy'
publishedAt: '2022-02-06'
summary: ''
image: '/static/images/all-start-here/og.png'
categories: 'laravel,php'
language: 'es'
---

Fuente de inspiración para escribir este artículo: [Colin Decarlo - Design Patterns with Laravel](https://www.youtube.com/watch?v=e4ugSgGaCQ0)

# Patrones de diseño cuando empiezas

Cuando uno empieza en este mundo de la programación a tirar sus primeras líneas de código ni siquiera se plantea una forma mejor de hacer las cosas, estás tan concentrado en aprender la sintaxis del lenguaje de programación y como las piezas se unen entre si para hacer una simple petición HTTP o iterar un array que te olvidas completamente del código limpio.

**Y ESTÁ BIEN**

Esta iniciación la sufrimos todos y hasta que no mecanizamos el proceso de programar tanto muscularmente en nuestros dedos como en nuestra mente no pensamos en ir un paso mas alla.
Cuando uno quiere mejorar y empieza a leer artículos o ver ejemplos de [código limpio](https://refactoring.guru/refactoring/what-is-refactoring) porque en su trabajo o proyecto de hobby tiene un controlador con mas de 800 lineas y no sabe como se ha descontrolado la situación te encuentras con este tema de 'Patrones de diseño' donde en la mayoría de ellos te da tan fuerte en la cara que te vuelves a plantear si de verdad sabes programar.

**Y ESTÁ BIEN**

Según mi experiencia muchos de los patrones de diseño que aprendemos al principio no sabemos realmente como aplicarlos en un caso real o cual de ellos elegir, en este artículo te mostraré dos de los grandes players en este mundo: [Adapter Pattern](https://refactoring.guru/design-patterns/strategy) & [Strategy Pattern](https://refactoring.guru/design-patterns/adapter)

## Adapter

Este patrón pertenece a la categoría de los estructurales y según [refactoring.guru](https://refactoring.guru) la definición acertada es: **_Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient._**

**_Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate_**

¿Cual sería un buen caso de uso donde realmente necesitemos este patrón a la hora de aplicarlo en nuestra base de código?

### Comunicación con servicios de terceros

El caso mas usado para este patrón es el de comunicación con servicios de terceros como pueden ser la Api de Google maps, Stripe, una base de datos externa para obtener códigos postales, etc. Toda comunicación con servicios del exterior donde nosotros no somos responsables de su funcionamiento.

#### Beneficios

- Inversión de dependencias (tienen que cumplir la interfaz que implementan de nuestro negocio)
- Cambiar de implementación de forma simple (En lugar de Google maps puedo cambiar a Mapbox con una simple variable)
- Fácil de testear (No tengo que comunicarme con sus servicios, solo testear las reglas de mi interfaz que harán mis tests mucho más rapidos y fiables)

### Ejemplo práctico con PHP

Aunque yo usaré PHP, los patrones de diseño se aplican a todos los lenguajes de forma similar por lo que solo cambiaran temas de sintaxis si usaras otro como Typescript por ejemplo.

---

**_Nuestra aplicación necesita los datos de geolocalización para determinar la cercanía de los propiedades que están en alquiler según la ubicación del usuario, usaremos como servicio principal Google Geocoding Api pero si su infrastructura cae queremos cambiar a Mapbox y seguir proporcionando el mismo servicio._**

---

Imáginate que tenemos que implementar esta nueva feature en nuestra app, la mayoría empezará a tirar código tipo, creo una clase para el servicio de Google y otra para Mapbox y cuando necesitamos cambiar pues llamamos al constructor del otro, bla bla bla...

**_Nota:_** _Las clases de los siguientes servicios no representan funciones reales de Google maps o Mapbox, es solo para representar la integración de este patrón_

Y se nos queda una cosa así:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class GeoCodingController extends Controller
{
    public function index(Request $request) {
         $locator = new \GoogleApiService($request);
         $location = $locator->findByIpAddress($request->ip());

        $map_position = new MapPosition(
            $location['country'],
            $location['state'],
            $location['city'],
            $location['latitude'],
            $location['longitude']
        );

        $properties = Properties::near($map_position)->get();

        return PropertiesResource::collection($properties);
    }

    // Si quisieramos cambiar a Mapbox se nos quedaría algo así por ejemplo
    public function index(Request $request) {
        $locator = new \MapBoxApiService($request);
        $location = $locator->findByIp($request->ip());

        $map_position = new MapPosition(
            $location['country'],
            $location['state_or_province'],
            $location['city_name'],
            $location['lat'],
            $location['lng']
        );

        $properties = Properties::near($map_position)->get();

        return PropertiesResource::collection($properties);
    }
}
```

A simple vista parece que está todo correcto y hace su trabajo pero nos encontramos con algunos problemas:

- El controlador sabe de la implementación del servicio y esta recibiendo el objeto Request del framework para inicializarse _(este código es de ejemplo pero lo he visto en casos reales)_
- Aunque es cierto que utilizamos nuestra clase MapPosition de nuestra App en ambos casos para representar la posición en el mapa, el metodo para obtener los datos del servicio se llama de forma diferente por lo que ya no solo tenemos que cambiar la clase a inicializar, si no el metodo a llamar _(En uno es findByIpAddress y en el otro findByIp)_.
- Los parámetros que recibe MapPosition tienen que ser cambiados según el servicio a utilizar _(location['state'] por location['state_or_province'])_

### Aplicando el patrón Adapter en este caso

Como vimos hace un momento, ya es mas de una parte del código que tenemos que cambiar en nuestro controlador para poder usar la localización. Antes de aplicarlo debemos definir que tipo de interfaz utilizarán en común estos servicios ya que se utilizará como 'Adaptador' entre la respuesta del servicio de terceros y el código de nuestra app.
Podríamos empezar con algo así:

```php
<?php
// Los namespaces y clases no tienen porque ser igual en tu app
namespace Domain\Map\Contracts;

use Domain\Map\MapPosition;
use Domain\Shared\ValueObjects\IP

interface LocatorContract
{
    /**
     * @param IP $ip
     * @return MapPosition $map_position - The map position data
     */
    public function fromIp(IP $ip): MapPosition;
}
```

Esta interfaz si define nuestra lógica de negocio ya que la funcionalidad que queremos es obtener la posición del mapa del usuario a través de su IP, el como se haga depende de la implementación que queramos usar.

Bien, una vez definido el contrato en común que tendrán ambos servicios, podemos ya usar a nuestro favor la inversión de dependencias con el service container de Laravel.

Primero aprovechare el sistema de archivos de configuración que me proporciona el framework de Laravel para obtener los datos importantes que necesitará cada implementación.

`app\config\map.php`

```php
<?php
return [
    'locator' => 'mapbox',
    'drivers' => [
        'mapbox' => [
            'url' => 'https://api.mapbox.com',
            'version' => 'v5',
            'params' => [
                'language' => 'es',
                'country' => 'es',
                'access_token' => env('MAPBOX_TOKEN'),
            ],
        ],
         'google_maps' => [
            'url' => 'https://maps.googleapis.com/maps/api',
            'version' => 'v2',
            'params' => [
                'language' => 'es',
                'country' => 'es',
                'access_token' => env('GOOGLE_API_TOKEN'),
            ],
        ]
    ]
];

```

Una vez hecho esto y centralizada la configuración de mis servicios de mapas, puedo definir el bind de mi interfaz para determinar la implementación de clase necesaria según el locator activo que tengo definido en mi archivo de configuración.

`App\Providers\AppServiceProvider.php`

```php
<?php

namespace App\Providers;


use Illuminate\Support\ServiceProvider;
use Application\Map\Services\Locator\{MapBoxLocator, GoogleMapsLocator};
use Domain\Map\Contracts\LocatorContract;
use RuntimeException;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        $this->app->singleton(LocatorContract::class, function ($app) {
            $map_config = $app->make('config')->get('map');
            $locator = $map_config['locator'];

            switch ($locator) {
                case 'mapbox':
                    return new MapBoxLocator($map_config['drivers'][$locator]);
                case 'google_maps':
                    return new GoogleMapsLocator($map_config['drivers'][$locator]);
                default:
                    throw new RuntimeException("The map locator is not defined in the config file");
            }
        });
    }
```

Se podría aplicar un pequeño refactor y definir directamente la configuración del driver en el constructor de cada clase y simplemente instanciar pero las cosas podrían cambiar a corto/medio plazo y esta configuración podría tener otra fuente y no el framework de Laravel por ejemplo. Esto ya es según las necesidades del proyecto.

### Limpiando nuestro controlador utilizando nuestro patrón Adapter

Si aplicamos estos cambios en nuestro controlador podemos ver que tenemos algo mas limpio y tolerable al cambio que al inicio:

```php
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Domain\Map\Contracts\LocatorContract as Locator;
use Domain\Shared\ValueObjects\IP;

class GeoCodingController extends Controller
{
    public function index(Request $request, Locator $locator) {
        $map_position = $locator->findByIp(new IP($request->ip()));

        $properties = Properties::near($map_position)->get();

        return PropertiesResource::collection($properties);
    }
```

Ahora podemos decir que tenemos código limpio con 3 líneas que hacen todo lo que necesitamos en nuestra primera fase de la feature _(quedaría el tema de captura de excepciones, cambio de servicio en condiciones de timeout pero para mantener el artículo centrado en patrones de diseño no me voy a meter en este asunto aún)_

Aquí puedes ver las implementaciones de cada clase separada, ten en cuenta que han sido simplificadas para beneficio del artículo pero la implementación puede ser tan compleja como lo necesites, lo importante es que cumplan el contrato de la interfaz:

`MapBoxLocator.php`

```php
<?php
//...
namespace Application\Map\Services\Locator;
use Domain\Map\Contracts\LocatorContract;

class MapBoxLocator implements LocatorContract
{
    private array $config;

    public function __construct(array $config): void {
        //...
    }

    public function fromIp(IP $ip): MapPosition {
         $location = $this->findByIp($ip);

        return new MapPosition(
            $location['country'],
            $location['state_or_province'],
            $location['city_name'],
            $location['lat'],
            $location['lng']
        );
    }
    //...
}
```

`GoogleMapsLocator.php`

```php
<?php
//...
namespace Application\Map\Services\Locator;
use Domain\Map\Contracts\LocatorContract;

class GoogleMapsLocator implements LocatorContract
{
    private array $config;

    public function __construct(array $config): void {
        //...
    }

    public function fromIp(IP $ip): MapPosition {
         $location = $this->findByIpAddress($ip);

        return new MapPosition(
            $location['country'],
            $location['state'],
            $location['city'],
            $location['latitude'],
            $location['longitude']
        );
    }
    //...
}
```

No solo obtenemos un código limpio sino también reutilizable, ahora podremos usarlo en otras partes de nuestra aplicación como por ejemplo un comando de consola desde Laravel:

```bash
php artisan geolocator:ip 169.165.84.191
```

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Domain\Shared\ValueObjects\IP;
use Domain\Map\Contracts\LocatorContract as Locator;

class GeoLocatorFromIp extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'geolocator:ip {ip}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Command description';

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle(LocatorContract $locator)
    {
           $map_position = $locator->findByIp(new IP($this->argument('ip'));

        //Do your stuff...
    }
}
```

### Creando los tests

Espero que hayas podido entender la base para este patrón Adapter y empezar a hacer tus propias implementaciones haciendo tu código no solo mas corto sino también tolerable al cambio y reutilizable a través de tu aplicación.

## Strategy pattern
